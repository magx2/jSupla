package pl.grzeslowski.jsupla.protocol.api.calltypes;

//@RunWith(Parameterized.class)
public class CallTypeParserImplTest {
//    private final CallTypeParserImpl callTypeParser = new CallTypeParserImpl();
//
//    private final CallType callType;
//
//    public CallTypeParserImplTest(CallType callType) {
//        this.callType = callType;
//    }
//
//    @Parameterized.Parameters
//    public static Collection<Object[]> data() {
//        return Stream.of(ServerDeviceClientCallType.values(),
//                ServerDeviceCallType.values(),
//                ServerClientCallType.values(),
//                DeviceServerCallType.values(),
//                DeviceClientServerCallType.values(),
//                ClientServerCallType.values())
//            .flatMap(Stream::of)
//            .map(v -> (CallType) v)
//            .map(callType -> new Object[]{callType})
//            .collect(Collectors.toList());
//    }
//
//    @Test
//    public void shouldFindProperCallType() throws Exception {
//        // when
//        final Optional<CallType> parseCallTypeOptional = callTypeParser.parse(callType.getValue());
//
//        // then
//        assertThat(parseCallTypeOptional).contains(callType);
//    }
}