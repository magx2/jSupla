package pl.grzeslowski.jsupla.protocol.api.calltypes;

// @RunWith(Parameterized.class)
public class CallTypeParserImplTest {
    //    private final CallTypeParserImpl callTypeParser = new CallTypeParserImpl();
    //
    //    private final CallType callType;
    //
    //    public CallTypeParserImplTest(CallType callType) {
    //        this.callType = callType;
    //    }
    //
    //    @Parameterized.Parameters
    //    public static Collection<Object[]> data() {
    //        return Stream.of(ServerDeviceClientCallType.values(),
    //                ServerDeviceCallType.values(),
    //                ServerClientCallType.values(),
    //                DeviceServerCallType.values(),
    //                DeviceClientServerCallType.values(),
    //                ClientServerCallType.values())
    //            .flatMap(Stream::of)
    //            .map(v -> (CallType) v)
    //            .map(callType -> new Object[]{callType})
    //            .collect(Collectors.toList());
    //    }
    //
    //    @Test
    //    public void shouldFindProperCallType() throws Exception {
    //        // when
    //        final Optional<CallType> parseCallTypeOptional =
    // callTypeParser.parse(callType.getValue());
    //
    //        // then
    //        assertThat(parseCallTypeOptional).contains(callType);
    //    }
}
