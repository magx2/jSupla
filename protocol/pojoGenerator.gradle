import groovy.json.JsonSlurper

import java.nio.file.Files
import java.nio.file.Path
import java.time.ZonedDateTime
import java.util.stream.Collectors
import java.util.stream.Stream

static void generatePojo(struct, Path generatedSourceRoot) {
	def path = "api.structs"
	def prefix = struct.prefix
	if (prefix != "T") {
		path += "/" + prefix.toLowerCase().substring(1)
	}
	def imports = new TreeSet<>([
		"import static pl.grzeslowski.jsupla.Preconditions.*",
		"import static pl.grzeslowski.jsupla.protocol.api.consts.JavaConsts.*",
		"import static pl.grzeslowski.jsupla.protocol.api.consts.ProtoConsts.*",
		"import pl.grzeslowski.jsupla.protocol.api.types.ProtoWithSize",
		"import pl.grzeslowski.jsupla.protocol.api.structs.*",
	])
	def javaName = struct.name
	def javaDoc = buildJavaDoc(struct)
	def constructorProperties = buildConstructorProperties(struct)
	def constructorAssignments = buildConstructorAssignments(struct)
	def properties = buildProperties(struct)
	def implementClass = findImplementClass(struct)
	def callType = findCallType(struct)
	def size = findSizeForClass(struct)
	def content = """\
		|package pl.grzeslowski.jsupla.protocol.${path.replaceAll("/", ".")};
		|
		|${String.join(";\n|", imports)};
		|
		|$javaDoc
		|@lombok.EqualsAndHashCode @lombok.ToString
		|@javax.annotation.Generated(value="Struct original name: ${struct.rawName}", date = "${ZonedDateTime.now()}")
		|public class ${javaName} implements ${implementClass} {
		|	$properties
		|
		|	public ${javaName}(${constructorProperties}) {
		|		${constructorAssignments}
		|	}
		|	
		|	$callType	
		|
		|	@Override
		|	public int size() {
		|		return ${size}
		|			;
		|	}
		|}
		|""".stripMargin()


	def toWrite = generatedSourceRoot.resolve(path).resolve(javaName + ".java")
	Files.createDirectories(toWrite.parent)
	toWrite.write(content)
}

task pojoGenerator {
	doLast {
		def jsonFile = new File(project.file("build/parser"), "proto.h.json")
		if (!jsonFile.exists()) {
			throw new IOException("File ${jsonFile.absolutePath} does not exists!")
		}

		def jsonSlurper = new JsonSlurper()
		def structs = jsonSlurper.parse(jsonFile) as List

		def generatedSourceRoot = project.file("build/generated/sources/jsupla/java/main/pl/grzeslowski/jsupla/protocol").toPath()
		Files.createDirectories(generatedSourceRoot)

		structs.forEach { generatePojo(it, generatedSourceRoot) }
	}
}
pojoGenerator.dependsOn "parseProtoh"
compileJava.dependsOn "pojoGenerator"

static String buildJavaDoc(struct) {
	def javaDoc = "/**\n"
	if (struct.javaDoc) {
		javaDoc += Arrays.stream(struct.javaDoc.toString().split("\n"))
			.map { " * $it" }
			.collect(Collectors.joining("\n")) + "\n\n<p>\n\n"
	}
	if (struct.raw) {
		javaDoc += "Original code:\n<pre>\n"
		javaDoc += struct.raw.toString()
			.replaceAll("<", "&#60;")
			.replaceAll(">", "&#62;")
			.replaceAll("@", "&#64;")
		javaDoc += "\n</pre>"
	}
	return javaDoc + "\n*/"
}

static String buildConstructorProperties(struct) {
	struct.fields.stream()
		.flatMap { field ->
			if (field.originalClassName == "SimpleField") {
				Stream.of(buildConstructorProperty(field))
			} else if (field.originalClassName == "UnionField") {
				field.fields.stream().map { buildConstructorProperty(it) }
			} else {
				throw new IllegalArgumentException("Unknown type: " + field.originalClassName.toString())
			}
		}
		.collect(Collectors.joining(",\n\t\t\t"))
}

static String buildConstructorProperty(field) {
	"${mapSuplaTypeToJava(field)} ${field.name}"
}

static String buildConstructorAssignments(struct) {
	struct.fields
		.stream()
		.flatMap { field ->
			if (field.originalClassName == "SimpleField") {
				return Stream.of(buildConstructorAssignment(field))
			} else if (field.originalClassName == "UnionField") {
				def assignments = field.fields.stream().map { buildConstructorAssignment(it) }
				def union = field.fields
					.stream()
					.map { it.name }
					.collect(Collectors.joining(", "))
				//noinspection GroovyAssignabilityCheck
				return Stream.concat(
					assignments,
					Stream.of("unionCheck($union);")
				)
			}
		}
		.collect(Collectors.joining("\n\t\t|\t\t"))
}

static String buildConstructorAssignment(field) {
	def value = field.name
	if (field.array) {
		def size = "(int) ${field.arraySize}"
//				if (preconditions.containsKey(value)) {
//					def precondition = preconditions.get(value)
//					if (precondition.value == "length") {
//						size = precondition.variable
//					}
//				}
		value = "checkArrayLength(${value}, $size)"
	}
	if (field.unsigned) {
		value = "unsigned(${value})"
	}
	"this.${field.name} = $value;"
}

static String mapSuplaTypeToJava(field) {
	def array = field.array ? "[]" : ""
	if (field.unsigned) {
		if (field.type == "_supla_int_t") {
			return "long" + array
		}
		if (field.type == "int") {
			return "long" + array
		}
		if (field.type == "char") {
			return "short" + array
		}
		if (field.type == "_supla_int16_t") {
			return "int" + array
		}
		if (field.type == "short") {
			return "int" + array
		}
		if (field.type == "_supla_int64_t") {
			return "long" + array
		}
	} else {
		if (field.type == "_supla_int_t") {
			return "int" + array
		}
		if (field.type == "int") {
			return "int" + array
		}
		if (field.type == "_supla_int16_t") {
			return "short" + array
		}
		if (field.type == "short") {
			return "short" + array
		}
		if (field.type == "_supla_int64_t") {
			return "long" + array
		}
		if (field.type == "char") {
			return "byte" + array
		}
	}
	return findImportClass(field) + field.type + array
}

static String findImportClass(field) {
	if (field.rawPrefix == "T") {
		return "pl.grzeslowski.jsupla.protocol.api.structs."
	} else if (field.rawPrefix == "TCS") {
		return "pl.grzeslowski.jsupla.protocol.api.structs.cs."
	} else if (field.rawPrefix == "TDCS") {
		return "pl.grzeslowski.jsupla.protocol.api.structs.dcs."
	} else if (field.rawPrefix == "TDS") {
		return "pl.grzeslowski.jsupla.protocol.api.structs.ds."
	} else if (field.rawPrefix == "TSC") {
		return "pl.grzeslowski.jsupla.protocol.api.structs.sc."
	} else if (field.rawPrefix == "TSD") {
		return "pl.grzeslowski.jsupla.protocol.api.structs.sd."
	} else if (field.rawPrefix == "TSDC") {
		return "pl.grzeslowski.jsupla.protocol.api.structs.sdc."
	} else if (field.rawPrefix == "TSCS") {
		return "pl.grzeslowski.jsupla.protocol.api.structs.scs."
	} else {
		throw new IllegalArgumentException("Unknown raw prefix: " + field.rawPrefix)
	}
}

static String buildProperties(struct) {
	struct.fields
		.stream()
		.flatMap { field ->
			if (field.originalClassName == "SimpleField") {
				Stream.of(buildSimpleProperty(field))
			} else if (field.originalClassName == "UnionField") {
				field.fields.stream().map { buildSimpleProperty(it) }
			} else {
				throw new IllegalArgumentException("Unknown type: " + field.originalClassName.toString())
			}
		}
		.collect(Collectors.joining("\n\t|\t"))
}

static String buildSimpleProperty(field) {
	def type = mapSuplaTypeToJava(field)
	def comment = ""
	if (field.javaDoc || field.unsigned) {
		comment += "/**\n"
		if (field.javaDoc) {
			comment += "\t * ${field.javaDoc}\n"
		}
		if (field.unsigned) {
			if (field.javaDoc) {
				comment += "\t * <p>\n"
			}
			comment += "\t * unsigned ${field.type}\n"
		}
		comment += "\t */\n\t"
	}
	"${comment}public final ${type} ${field.name};"
}

static String findImplementClass(struct) {
	def prefix = struct.prefix
	if (prefix == "TCS") {
		return "pl.grzeslowski.jsupla.protocol.api.structs.cs.ClientServer"
	} else if (prefix == "TDCS") {
		return "pl.grzeslowski.jsupla.protocol.api.structs.dcs.DeviceClientServer"
	} else if (prefix == "TDS") {
		return "pl.grzeslowski.jsupla.protocol.api.structs.ds.DeviceServer"
	} else if (prefix == "TSC") {
		return "pl.grzeslowski.jsupla.protocol.api.structs.sc.ServerClient"
	} else if (prefix == "TSD") {
		return "pl.grzeslowski.jsupla.protocol.api.structs.sd.ServerDevice"
	} else if (prefix == "TSDC") {
		return "pl.grzeslowski.jsupla.protocol.api.structs.sdc.ServerDeviceClient"
	}
	return "pl.grzeslowski.jsupla.protocol.api.types.ProtoWithSize"
}

// todo set call type
static String findCallType(struct) {
	def clazz = findImplementClass(struct)
	if (clazz == "pl.grzeslowski.jsupla.protocol.api.types.ProtoWithSize") {
		return "/* no call type */"
	}

	def returnValue = "pl.grzeslowski.jsupla.protocol.api.calltypes." + clazz.split("\\.")[-1]
	return """
			|	@Override
    		|	public ${returnValue}CallType callType() {
        	|		return null; // todo no call type
    		|	}""".stripMargin()
}

static String findSizeForClass(struct) {
	struct.fields
		.stream()
		.map { field ->
			if (field.originalClassName == "SimpleField") {
				return findSizeForField(field)
			} else if (field.originalClassName == "UnionField") {
				def sizes = field.fields
					.stream()
					.map { findSizeForField(it) }
					.collect(Collectors.joining("\n\t\t\t,"))
				return "pl.grzeslowski.jsupla.protocol.api.consts.JavaConsts.unionSize(\n\t\t\t$sizes\n\t\t)"
			} else {
				throw new IllegalArgumentException("Unknown type: " + field.originalClassName.toString())
			}
		}
		.collect(Collectors.joining("\n\t\t + "))
}

static String findSizeForField(field) {
	findSize(field) + " // ${field.name}"
}

static String findSize(field) {
	if (field.unsigned) {
		if (field.type == "_supla_int64_t") {
			return "LONG_SIZE"
		} else if (field.type == "short") {
			return "SHORT_SIZE"
		} else if (field.type == "_supla_int_t") {
			return "INT_SIZE"
		} else if (field.type == "int") {
			return "INT_SIZE"
		} else if (field.type == "char") {
			return "CHAR_SIZE"
		} else if (field.type == "_supla_int16_t") {
			return "SHORT_SIZE"
		} else {
			throw new IllegalArgumentException("Unknown unsigned type: " + field.type)
		}
	} else if (field.array) {
		def xSize = mapSimpleType(field.type)
		if (xSize.startsWith("UNKNOWN")) {
			return "arraySize(" + field.name + ")"
		} else {
			if (field.arraySize) {
				return "(int) ${field.arraySize} * ${xSize}"
			} else {
				return "${field.name}.length * ${xSize}"
			}
		}
	} else {
		def finalType = mapSimpleType(mapSuplaTypeToJava(field))
		if (finalType.startsWith("UNKNOWN")) {
			finalType = field.name + ".size()"
		}
		return finalType
	}
}

static String mapSimpleType(String type) {
	if (type == "int") {
		return "INT_SIZE"
	} else if (type == "char" || type == "byte") {
		return "BYTE_SIZE"
	} else if (type == "short") {
		return "SHORT_SIZE"
	} else if (type == "long") {
		return "LONG_SIZE"
	} else if (type == "_supla_int16_t") {
		return "SHORT_SIZE"
	} else if (type == "_supla_int_t") {
		return "INT_SIZE"
	}
	return "UNKNOWN_" + type
}