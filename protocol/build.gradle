import java.nio.file.Files
import java.time.ZonedDateTime
import java.util.stream.Collectors

dependencies {
	compile rootProject.project("common")
	implementation group: 'javax.annotation', name: 'javax.annotation-api', version: '1.3.2'
}

sourceSets {
	main {
		java.srcDirs += "${project.buildDir}/generated/sources/jsupla/java/main"
	}
}

static def generateCallTypeClass(File file, String shortName, List list) {
	def name = Arrays.stream(shortName.split(""))
		.map {
			if (it == "d") return "Device"
			if (it == "c") return "Client"
			if (it == "s") return "Server"
		}
		.collect(Collectors.joining()) + "CallType"
	def values = list.stream()
		.map { "${it.name}(${it.value})" }
		.collect(Collectors.joining(", \n\t"))

	def java = """
		|package pl.grzeslowski.jsupla.protocol.api.calltypes;
		|
		|@javax.annotation.Generated(value="${file.absolutePath.replaceAll("\\\\", "\\\\\\\\")}", date = "${ZonedDateTime.now()}", comments = "generated from ${file.name}")
		|public enum ${name} implements CallType {
		|	$values ;
		|	private final int value;
		|
		|	${name}(int value) {
		|		this.value = value;
		|	}
		|
		|	@Override
		|	public int getValue() {
		|		return value;
		|	}
		|}""".stripMargin()
	return [name: name, java: java]
}

task buildCallTypes {
	doLast {
		logger.info("Building Call Types")
		def file = project.file("src/main/native/CallTypes.h")
		def dcs = new ArrayList<>()
		def ds = new ArrayList<>()
		def sdc = new ArrayList<>()
		def cs = new ArrayList<>()
		def sd = new ArrayList<>()
		def sc = new ArrayList<>()
		def csd = new ArrayList<>()
		def dsc = new ArrayList<>()
		def scd = new ArrayList<>()
		file
			.readLines()
			.stream()
			.filter { it.startsWith("#define") }
			.map { line ->
				line = line.replaceAll("#define ", "")

				def split = line.split(" ", 3)
				def name = split[0]
				def value = split[1]

				return [name: name, value: value]
			}
			.forEach { obj ->
				if (obj.name.startsWith("SUPLA_DCS_")) {
					dcs.add(obj)
				} else if (obj.name.startsWith("SUPLA_DS_")) {
					ds.add(obj)
				} else if (obj.name.startsWith("SUPLA_SDC_")) {
					sdc.add(obj)
				} else if (obj.name.startsWith("SUPLA_CS_")) {
					cs.add(obj)
				} else if (obj.name.startsWith("SUPLA_SD_")) {
					sd.add(obj)
				} else if (obj.name.startsWith("SUPLA_SC_")) {
					sc.add(obj)
				} else if (obj.name.startsWith("SUPLA_CSD_")) {
					csd.add(obj)
				} else if (obj.name.startsWith("SUPLA_DSC_")) {
					dsc.add(obj)
				} else if (obj.name.startsWith("SUPLA_SCD_")) {
					scd.add(obj)
				} else {
					throw new IllegalStateException("${obj.name} does not match any list!")
				}
			}

		def classes = [
			generateCallTypeClass(file, "dcs", dcs),
			generateCallTypeClass(file, "ds", ds),
			generateCallTypeClass(file, "dsc", dsc),
			generateCallTypeClass(file, "sdc", sdc),
			generateCallTypeClass(file, "sd", sd),
			generateCallTypeClass(file, "sc", sc),
			generateCallTypeClass(file, "scd", scd),
			generateCallTypeClass(file, "cs", cs),
			generateCallTypeClass(file, "csd", csd),
		]

		def generatedDir = project.file("build/generated/sources/jsupla/java/main/pl/grzeslowski/jsupla/protocol/api/calltypes").toPath()
		Files.createDirectories(generatedDir)

		classes.forEach {
			generatedDir.resolve(it.name + ".java").write(it.java)
		}
	}
}
compileJava.dependsOn "buildCallTypes"

task generateProtoConst {
	doLast {
		logger.info("Building Call Types")

		def file = project.file("src/main/native/ProtoConsts.h")
		def consts = file
			.readLines()
			.stream()
			.filter { it.startsWith("#define") }
			.map { line ->
				line = line.replaceAll("#define ", "").trim()

				def split = line.split(" ", 2)
				def name = split[0]
				def value = split[1]

				if (value.contains("//")) {
					def valueSplit = value.split("//", 2)
					value = valueSplit[0] + "; //" + valueSplit[1]
				}

				return [name: name, value: value, deprecated: value.toUpperCase().endsWith("DEPRECATED")]
			}
			.map {
				def line = ""
				if (it.deprecated) {
					line += "@java.lang.Deprecated "
				}
				line += "public static final int ${it.name} = ${it.value};"
				return line;
			}
			.collect(Collectors.joining("\n|\t"))

		def java = """
			|package pl.grzeslowski.jsupla.protocol.api.consts;
			|
			|@javax.annotation.Generated(value="${file.absolutePath.replaceAll("\\\\", "\\\\\\\\")}", date = "${ZonedDateTime.now()}", comments = "generated from ProtoConsts.h")
			|public interface ProtoConsts {
			|
			|	public static final byte[] SUPLA_TAG = new byte[]{83, 85, 80, 76, 65};
			|
			|	$consts
			|}""".stripMargin()

		def generatedDir = project.file("build/generated/sources/jsupla/java/main/pl/grzeslowski/jsupla/protocol/api/consts").toPath()
		Files.createDirectories(generatedDir)
		generatedDir.resolve("ProtoConsts.java").write(java)
	}
}
compileJava.dependsOn "generateProtoConst"

static String camelCase(String name) {
	name = name.replaceAll("GUID", "Guid")
	name = name.replaceAll("ID", "Id")
	name = name[0].toLowerCase() + name.substring(1)
	// remove underscores
	def newName = ""
	for (def i = 0; i < name.length(); i++) {
		def first = name[i]
		if (first != '_') {
			newName += name[i]
		} else {
			newName += name[i + 1].toUpperCase()
			i++
		}
	}
	return newName
}

static String mapSuplaTypeToJava(type) {
	if (type.unsigned) {
		if (type.value == "_supla_int_t") {
			return "long"
		}
		if (type.value == "char") {
			return "short"
		}
	} else {
		if (type.value == "_supla_int_t") {
			return "int"
		}
		if (type.value == "_supla_int16_t") {
			return "short"
		}
	}
	return type.value
}

static String mapSimpleType(String type) {
	if (type == "int") {
		return "INT_SIZE"
	} else if (type == "char" || type == "byte") {
		return "BYTE_SIZE"
	} else if (type == "short") {
		return "SHORT_SIZE"
	}
	return "UNKNOWN_" + type
}

def compileStruct(java.nio.file.Path structsDir, java.nio.file.Path structFile) {
	def typeMaps = new HashMap<String, String>()
	def imports = new TreeSet<>([
		"import static pl.grzeslowski.jsupla.Preconditions.*",
		"import static pl.grzeslowski.jsupla.protocol.api.consts.JavaConsts.*",
		"import static pl.grzeslowski.jsupla.protocol.api.consts.ProtoConsts.*",
		"import pl.grzeslowski.jsupla.protocol.api.types.ProtoWithSize",
	])
	def extendsClass = "ProtoWithSize"
	def callType = null
	def preconditions = new HashMap<String, Object>()
	def staticSize = false
	structFile.readLines()
		.stream()
		.filter { it.startsWith("// instruction ") }
		.map { it.substring("// instruction ".length()) }
		.forEach { instruction ->
			instruction = instruction.split(" ")
			def keyword = instruction[0]
			if (keyword == "map") {
				typeMaps[instruction[1]] = instruction[2]
			} else if (keyword == "import") {
				imports.add("import " + instruction[1])
			} else if (keyword == "extends") {
				extendsClass = instruction[1]
				if (extendsClass == "ClientServer") {
					imports.add("import pl.grzeslowski.jsupla.protocol.api.structs.cs.ClientServer")
				} else if (extendsClass == "DeviceClientServer") {
					imports.add("import pl.grzeslowski.jsupla.protocol.api.structs.dsc.DeviceClientServer")
				} else if (extendsClass == "DeviceServer") {
					imports.add("import pl.grzeslowski.jsupla.protocol.api.structs.ds.DeviceServer")
				} else if (extendsClass == "ServerClient") {
					imports.add("import pl.grzeslowski.jsupla.protocol.api.structs.sc.ServerClient")
				} else if (extendsClass == "ServerDevice") {
					imports.add("import pl.grzeslowski.jsupla.protocol.api.structs.sd.ServerDevice")
				} else if (extendsClass == "ServerDeviceClient") {
					imports.add("import pl.grzeslowski.jsupla.protocol.api.structs.sdc.ServerDeviceClient")
				}
				callType = instruction[2]
				imports.add("import static pl.grzeslowski.jsupla.protocol.api.calltypes.${extendsClass}CallType.$callType")
				imports.add("import pl.grzeslowski.jsupla.protocol.api.calltypes.${extendsClass}CallType")
			} else if (keyword == "precondition") {
				preconditions[instruction[1]] = [value: instruction[2], variable: instruction[3]]
			} else if (keyword == "size") {
				staticSize = instruction[1] == "static"
			} else {
				logger.log(LogLevel.ERROR, " > Unknown instruction: [${keyword}]")
			}
		}

	def rawProperties = structFile.readLines()
		.stream()
		.map { it.trim() }
		.filter { !it.isBlank() }
		.filter { !it.startsWith("//") }
		.map { line ->
			def split = line.split("//", 2)
			def code = split[0]
			def comment = null
			if (split.length > 1) {
				comment = split[1]
			}

			def unsigned = code.startsWith("unsigned")
			def codeSplit = code.replaceAll('unsigned ', '').split(" ", 2)

			def typeValue = codeSplit[0]
			if (typeMaps.containsKey(typeValue)) {
				typeValue = typeMaps[typeValue]
			}
			def type = [value: typeValue, array: false, arraySize: null as String, unsigned: unsigned]
			def name = codeSplit[1].replaceAll(";", "").trim()

			// check if this is not an array
			def regexPattern = /^(.*?)\[(.*?)\]$/
			def matcher = name =~ regexPattern
			if (matcher.matches()) {
				def match = matcher[0]
				type.array = true
				//noinspection GroovyAssignabilityCheck
				name = camelCase(match[1])
				//noinspection GroovyAssignabilityCheck
				type.arraySize = match[2]
				if (preconditions.containsKey(name)) {
					def precondition = preconditions.get(name)
					if (precondition.value == "length") {
						type.arraySize = precondition.variable
					}
				}
			} else {
				name = camelCase(name)
			}

			type.value = mapSuplaTypeToJava(type)

			return [type: type, name: name, comment: comment]
		}
		.collect(Collectors.toList())

	def className = structFile.fileName.toString().take(structFile.fileName.toString().lastIndexOf('.'))

	def relativize = structsDir.relativize(structFile.parent)
	def packageName = "pl.grzeslowski.jsupla.protocol.api.structs"
	if (relativize.toString()?.trim()) packageName += "." + relativize
	def properties = rawProperties
		.stream()
		.map { property ->
			def type = property.type.value
			if (property.type.array) {
				type += "[]"
			}
			def comment = ""
			if (property.comment || property.type.unsigned) {
				comment += "/**\n"
				if (property.comment) {
					comment += "\t * ${property.comment}\n"
				}
				if (property.type.unsigned) {
					comment += "\t * unsgigned ${property.type.value}\n"
				}
				comment += "\t */\n\t"
			}
			"${comment}private final ${type} ${property.name};"
		}
		.collect(Collectors.joining("\n\t|\t"))
	def constructorProperties = rawProperties
		.stream()
		.map { property ->
			def type = property.type.value
			if (property.type.array) {
				type += "[]"
			}
			"${type} ${property.name}"
		}
		.collect(Collectors.joining(", "))
	def constructorAssignments = rawProperties
		.stream()
		.map { property ->
			def value = property.name
			if (property.type.array) {
				def size = "(int) ${property.type.arraySize}"
				if (preconditions.containsKey(value)) {
					def precondition = preconditions.get(value)
					if (precondition.value == "length") {
						size = precondition.variable
					}
				}
				value = "checkArrayLength(${value}, $size)"
			}
			if (property.type.unsigned) {
				value = "unsigned(${value})"
			}
			"this.${property.name} = $value;"
		}
		.collect(Collectors.joining("\n\t\t|\t\t"))
	def callTypeJava = ""
	if (callType) {
		callTypeJava = """
			|	@Override
    		|	public ${extendsClass}CallType callType() {
        	|		return $callType;
    		|	}""".stripMargin()
	}
	def size = rawProperties
		.stream()
		.map { property ->
			def type = property.type
			def finalType = "UNKNOWN_FIX_SCRIPT // ${type.value}"
			if (type.unsigned) {
				if (type.value == "long") {
					finalType = "INT_SIZE"
				} else if (type.value == "short") {
					finalType = "BYTE_SIZE"
				}
			} else if (type.array) {
				def xSize = mapSimpleType(type.value)
				if (xSize.startsWith("UNKNOWN")) {
					xSize = "${type.value}.SIZE"
				}
				if (type.arraySize) {
					finalType = "${type.arraySize} * ${xSize}"
				} else {
					finalType = "${property.name}.length * ${xSize}"
				}
			} else {
				finalType = mapSimpleType(type.value)
				if (finalType.startsWith("UNKNOWN")) {
					finalType = property.name + ".size()"
				}
			}
			return finalType + " // ${property.name}"
		}
		.collect(Collectors.joining("\n\t\t + "))
	def staticSizeJava = "";
	if (staticSize) {
		staticSizeJava = "public static final int SIZE = $size\n;"
		size = "SIZE"
	}

	def java = """
		|package ${packageName};
		|
		|${String.join(";\n|", imports)};
		|
		|@lombok.EqualsAndHashCode @lombok.ToString
		|public final class ${className} implements ${extendsClass} {
		|	$staticSizeJava
		|	$properties
		|
		|	public ${className}(${constructorProperties}) {
		|		${constructorAssignments}
		|	}
		|	
		|	$callTypeJava
		|
		|	@Override
    	|	public int size() {
        |		return ${size}
		|			;
    	|	}
		|}
		|""".stripMargin()
	return java
}

task compileNativeStructs {
	doLast {
		def structsDir = project.file("src/main/native/pl/grzeslowski/jsupla/protocol/api/structs").toPath()
		def structs = Files.walk(structsDir)
			.filter { Files.isRegularFile(it) && it.toString().endsWith(".h") }
			.toList()
		for (def structPath : structs) {
			def compiled = compileStruct(structsDir, structPath)

			def fileName = structPath.fileName.toString().take(structPath.fileName.toString().lastIndexOf('.')) + ".java"
			def relativize = structsDir.relativize(structPath.parent)
			def javaFile = project.file("build/generated/sources/jsupla/java/main/pl/grzeslowski/jsupla/protocol/api/structs/").toPath().resolve(relativize).resolve(fileName)

			Files.createDirectories(javaFile.parent)
			javaFile.toFile().createNewFile()
			javaFile.write(compiled)
		}
	}
}
compileJava.dependsOn "compileNativeStructs"
compileNativeStructs.dependsOn "buildCallTypes"
compileNativeStructs.dependsOn "generateProtoConst"