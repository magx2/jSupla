apply from: 'parser.gradle'
apply from: 'pojoGenerator.gradle'

import java.nio.file.Files
import java.time.ZonedDateTime
import java.util.stream.Collectors

dependencies {
	compile rootProject.project("common")
	implementation group: 'javax.annotation', name: 'javax.annotation-api', version: '1.3.2'
}

sourceSets {
	main {
		java.srcDirs += "${project.buildDir}/generated/sources/jsupla/java/main"
	}
}

static def generateCallTypeClass(File file, String shortName, List list) {
	def name = Arrays.stream(shortName.split(""))
		.map {
			if (it == "d") return "Device"
			if (it == "c") return "Client"
			if (it == "s") return "Server"
		}
		.collect(Collectors.joining()) + "CallType"
	def values = list.stream()
		.map { "${it.name}(${it.value})" }
		.collect(Collectors.joining(", \n\t"))

	def java = """
		|package pl.grzeslowski.jsupla.protocol.api.calltypes;
		|
		|@javax.annotation.Generated(value="${file.absolutePath.replaceAll("\\\\", "\\\\\\\\")}", date = "${ZonedDateTime.now()}", comments = "generated from ${file.name}")
		|public enum ${name} implements CallType {
		|	$values ;
		|	private final int value;
		|
		|	${name}(int value) {
		|		this.value = value;
		|	}
		|
		|	@Override
		|	public int getValue() {
		|		return value;
		|	}
		|}""".stripMargin()
	return [name: name, java: java]
}

task buildCallTypes {
	doLast {
		logger.info("Building Call Types")
		def file = project.file("src/main/native/CallTypes.h")
		def dcs = new ArrayList<>()
		def ds = new ArrayList<>()
		def sdc = new ArrayList<>()
		def cs = new ArrayList<>()
		def sd = new ArrayList<>()
		def sc = new ArrayList<>()
		def csd = new ArrayList<>()
		def dsc = new ArrayList<>()
		def scd = new ArrayList<>()
		file
			.readLines()
			.stream()
			.filter { it.startsWith("#define") }
			.map { line ->
				line = line.replaceAll("#define ", "")

				def split = line.split(" ", 3)
				def name = split[0]
				def value = split[1]

				return [name: name, value: value]
			}
			.forEach { obj ->
				if (obj.name.startsWith("SUPLA_DCS_")) {
					dcs.add(obj)
				} else if (obj.name.startsWith("SUPLA_DS_")) {
					ds.add(obj)
				} else if (obj.name.startsWith("SUPLA_SDC_")) {
					sdc.add(obj)
				} else if (obj.name.startsWith("SUPLA_CS_")) {
					cs.add(obj)
				} else if (obj.name.startsWith("SUPLA_SD_")) {
					sd.add(obj)
				} else if (obj.name.startsWith("SUPLA_SC_")) {
					sc.add(obj)
				} else if (obj.name.startsWith("SUPLA_CSD_")) {
					csd.add(obj)
				} else if (obj.name.startsWith("SUPLA_DSC_")) {
					dsc.add(obj)
				} else if (obj.name.startsWith("SUPLA_SCD_")) {
					scd.add(obj)
				} else {
					throw new IllegalStateException("${obj.name} does not match any list!")
				}
			}

		def classes = [
			generateCallTypeClass(file, "dcs", dcs),
			generateCallTypeClass(file, "ds", ds),
			generateCallTypeClass(file, "dsc", dsc),
			generateCallTypeClass(file, "sdc", sdc),
			generateCallTypeClass(file, "sd", sd),
			generateCallTypeClass(file, "sc", sc),
			generateCallTypeClass(file, "scd", scd),
			generateCallTypeClass(file, "cs", cs),
			generateCallTypeClass(file, "csd", csd),
		]

		def generatedDir = project.file("build/generated/sources/jsupla/java/main/pl/grzeslowski/jsupla/protocol/api/calltypes").toPath()
		Files.createDirectories(generatedDir)

		classes.forEach {
			generatedDir.resolve(it.name + ".java").write(it.java)
		}
	}
}
compileJava.dependsOn "buildCallTypes"

task generateProtoConst {
	doLast {
		logger.info("Building Call Types")

		def file = project.file("src/main/native/ProtoConsts.h")
		def consts = file
			.readLines()
			.stream()
			.filter { it.startsWith("#define") }
			.map { line ->
				line = line.replaceAll("#define ", "").trim()

				def split = line.split(" ", 2)
				def name = split[0]
				def value = split[1]

				if (value.contains("//")) {
					def valueSplit = value.split("//", 2)
					value = valueSplit[0] + "; //" + valueSplit[1]
				}

				return [name: name, value: value, deprecated: value.toUpperCase().endsWith("DEPRECATED")]
			}
			.map {
				def line = ""
				if (it.deprecated) {
					line += "@java.lang.Deprecated "
				}
				line += "public static final int ${it.name} = ${it.value};"
				return line;
			}
			.collect(Collectors.joining("\n|\t"))

		def java = """
			|package pl.grzeslowski.jsupla.protocol.api.consts;
			|
			|@javax.annotation.Generated(value="${file.absolutePath.replaceAll("\\\\", "\\\\\\\\")}", date = "${ZonedDateTime.now()}", comments = "generated from ProtoConsts.h")
			|public interface ProtoConsts {
			|
			|	public static final byte[] SUPLA_TAG = new byte[]{83, 85, 80, 76, 65};
			|
			|	$consts
			|}""".stripMargin()

		def generatedDir = project.file("build/generated/sources/jsupla/java/main/pl/grzeslowski/jsupla/protocol/api/consts").toPath()
		Files.createDirectories(generatedDir)
		generatedDir.resolve("ProtoConsts.java").write(java)
	}
}
compileJava.dependsOn "generateProtoConst"

static String camelCase(String name) {
	name = name.replaceAll("GUID", "Guid")
	name = name.replaceAll("ID", "Id")
	name = name[0].toLowerCase() + name.substring(1)
	// remove underscores
	def newName = ""
	for (def i = 0; i < name.length(); i++) {
		def first = name[i]
		if (first != '_') {
			newName += name[i]
		} else {
			newName += name[i + 1].toUpperCase()
			i++
		}
	}
	return newName
}

static String mapSuplaTypeToJava(type) {
	if (type.unsigned) {
		if (type.value == "_supla_int_t") {
			return "long"
		}
		if (type.value == "char") {
			return "short"
		}
		if (type.value == "_supla_int16_t") {
			return "int"
		}
		if (type.value == "_supla_int64_t") {
			return "long"
		}
	} else {
		if (type.value == "_supla_int_t") {
			return "int"
		}
		if (type.value == "_supla_int16_t") {
			return "short"
		}
		if (type.value == "_supla_int64_t") {
			return "long"
		}
	}
	return type.value
}

static String mapSimpleType(String type) {
	if (type == "int") {
		return "INT_SIZE"
	} else if (type == "char" || type == "byte") {
		return "BYTE_SIZE"
	} else if (type == "short") {
		return "SHORT_SIZE"
	} else if (type == "long") {
		return "LONG_SIZE"
	}
	return "UNKNOWN_" + type
}

static String findSize(property) {
	def type = property.type
	def finalType = "UNKNOWN_FIX_SCRIPT // ${type.value}"
	if (type.unsigned) {
		if (type.value == "long") {
			finalType = "INT_SIZE"
		} else if (type.value == "short") {
			finalType = "BYTE_SIZE"
		} else if (type.value == "int") {
			finalType = "SHORT_SIZE"
		}
	} else if (type.array) {
		def xSize = mapSimpleType(type.value)
		if (xSize.startsWith("UNKNOWN")) {
			xSize = "${type.value}.SIZE"
		}
		if (type.arraySize) {
			finalType = "${type.arraySize} * ${xSize}"
		} else {
			finalType = "${property.name}.length * ${xSize}"
		}
	} else {
		finalType = mapSimpleType(type.value)
		if (finalType.startsWith("UNKNOWN")) {
			finalType = property.name + ".size()"
		}
	}
	return finalType
}
