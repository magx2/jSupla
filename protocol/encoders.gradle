import groovy.json.JsonSlurper

import java.nio.file.Files
import java.nio.file.Path
import java.time.ZonedDateTime

import static java.util.stream.Collectors.joining

task encodersGenerator {
	group = 'jSupla'
	inputs.file new File(project.file("build/parser"), "proto.h.json")
	outputs.dir project.file("build/generated/sources/jsupla/main/java/pl/grzeslowski/jsupla/protocol/")
	doLast {
		def jsonFile = new File(project.file("build/parser"), "proto.h.json")
		if (!jsonFile.exists()) {
			throw new IOException("File ${jsonFile.absolutePath} does not exists!")
		}

		def jsonSlurper = new JsonSlurper()
		def structs = (jsonSlurper.parse(jsonFile) as List)

		def generatedSourceRoot = project.file("build/generated/sources/jsupla/main/java/pl/grzeslowski/jsupla/protocol/").toPath()
		Files.createDirectories(generatedSourceRoot)

		structs
			.stream()
			.sorted { a, b -> a.rawName.compareTo(b.rawName) }
			.forEach { generateEncoder(it, generatedSourceRoot) }
	}
}
encodersGenerator.dependsOn "parseProtoh"
compileJava.dependsOn "encodersGenerator"

task encoderFactoryGenerator {
	group = 'jSupla'
	inputs.file new File(project.file("build/parser"), "proto.h.json")
	outputs.file project.file("build/generated/sources/jsupla/main/java/pl/grzeslowski/jsupla/protocol/api/encoders/EncoderFactoryImpl.java")
	doLast {
		def jsonFile = new File(project.file("build/parser"), "proto.h.json")
		if (!jsonFile.exists()) {
			throw new IOException("File ${jsonFile.absolutePath} does not exists!")
		}

		def jsonSlurper = new JsonSlurper()
		def structs = (jsonSlurper.parse(jsonFile) as List)

		def imports = [
			"import pl.grzeslowski.jsupla.protocol.api.types.ProtoWithSize;"
		].stream().collect(joining("\n"))
		def findEncoder = structs.stream()
			.sorted { a, b -> a.rawName.compareTo(b.rawName) }
			.map { findEncoder(it) }
			.collect(joining("\n"))

		def content = """\
			|package pl.grzeslowski.jsupla.protocol.api.encoders;
			|
			|$imports
			|
			|public class EncoderFactoryImpl implements EncoderFactory {
    		|	public static final EncoderFactoryImpl INSTANCE = new EncoderFactoryImpl();
			|
			|	@SuppressWarnings("unchecked")
    		|	@Override
    		|	public <T extends ProtoWithSize> Encoder<T> getEncoder(final Class<T> proto) {
			|$findEncoder
			|
			|		throw new IllegalArgumentException("Can't find encoder for class " + proto);
			|	}
			|}
			|""".stripMargin()

		def encoderFactoryImpl = project.file("build/generated/sources/jsupla/main/java/pl/grzeslowski/jsupla/protocol/api/encoders/EncoderFactoryImpl.java").toPath()
		Files.createDirectories(encoderFactoryImpl.parent)

		encoderFactoryImpl.write(content)
	}
}
encoderFactoryGenerator.dependsOn "encodersGenerator"
compileJava.dependsOn "encoderFactoryGenerator"

void generateEncoder(struct, Path generatedSourceRoot) {
	def path = "api/encoders"
	def javaName = struct.name + "Encoder"
	def prefix = struct.prefix
	if (prefix != "T") {
		path += "/" + prefix.toLowerCase().substring(1)
	}
	def toWrite = generatedSourceRoot.resolve(path).resolve(javaName + ".java")
	def sourcesPath = project.file("src/main/java/pl/grzeslowski/jsupla/protocol/").toPath().resolve(path).resolve(javaName + ".java")
	if (Files.exists(sourcesPath)) {
		logger.warn("Encoder {} already exists, ignoring...", sourcesPath.toFile().path)
		return
	}

	def classPackage = "pl.grzeslowski.jsupla.protocol.${path.replaceAll("/", ".")}"
	def imports = new TreeSet<>([
		"import lombok.val",
		"import pl.grzeslowski.jsupla.protocol.api.encoders.PrimitiveEncoder",
		"import static pl.grzeslowski.jsupla.protocol.api.JavaConsts.*",
		"import " + classPackage.replaceAll("encoders", "structs") + "." + struct.name,
		"import static pl.grzeslowski.jsupla.protocol.api.consts.ProtoConsts.*",
	])
	def implementClass = findImplementClass(struct)
	def structName = struct.name
	def hasUnionFields = struct.fields.stream().filter { it.originalClassName == "UnionField" }.findAny().isPresent()
	def parse
	if (!hasUnionFields) {
		String fields = struct.fields
			.stream()
			.map { field -> "\t\t${parseField(field)}" }
			.collect(joining("\n"))
		parse = """\
			|final byte[] bytes = new byte[proto.size()];
        	|int offset = 0;
        	|
        	|$fields""".stripMargin()
	} else {
		parse = "throw new java.lang.UnsupportedOperationException(\"Do not support encoding structs with unions!\");"
	}

	def content = """\
		|package $classPackage;
		|
		|${String.join(";\n|", imports)};
		|
		|@javax.annotation.Generated(value="Struct original name: ${struct.rawName}", date = "${ZonedDateTime.now()}")
		|@lombok.NoArgsConstructor(access = lombok.AccessLevel.PRIVATE)
		|public class ${javaName} implements ${implementClass}<${structName}> {
		|	public static final ${javaName} INSTANCE = new ${javaName}();
		|
		|   @Override
    	|	public byte[] encode($structName proto) {
		|$parse
		|		
    	|	    ${hasUnionFields ? "//" : ""}return bytes;
    	|	}
		|}
		|""".stripMargin()

	Files.createDirectories(toWrite.parent)
	toWrite.write(content)
}

static String findImplementClass(struct) {
	def prefix = struct.prefix
	if (prefix == "T") {
		return "pl.grzeslowski.jsupla.protocol.api.encoders.ProtoWithSizeEncoder"
	}
	prefix = prefix.toString().substring(1).toLowerCase()

	def implementClass = "pl.grzeslowski.jsupla.protocol.api.encoders.${prefix}."
	for (def letter : prefix) {
		def s
		if (letter == "c") {
			implementClass += "Client"
		} else if (letter == "s") {
			implementClass += "Server"
		} else if (letter == "d") {
			implementClass += "Device"
		} else {
			throw new IllegalArgumentException("[encoders] Unknown letter [$letter] !")
		}
	}
	return implementClass + "Encoder"
}

static String parseField(field) {
	if (!field.array) {
		if (isPrimitiveType(field.type)) {
			def sign = field.unsigned ? "Unsigned" : ""
			def type = mapSuplaTypeToJava(field.type).capitalize()
			return "offset += PrimitiveEncoder.INSTANCE.write${sign}${type}(proto.${field.name}, bytes, offset);"
		} else {
			return """\
				|byte[] ${field.name}Bytes = ${findEncoderImportForType(field.rawPrefix)}${field.type}Encoder.INSTANCE.encode(proto.${field.name});
				|		offset += ${field.name}Bytes.length;\
			""".stripMargin()
		}
	} else {
		if (isPrimitiveType(field.type)) {
			def sign = field.unsigned ? "Unsigned" : ""
			def type = mapSuplaTypeToJava(field.type).capitalize()
			return "offset += PrimitiveEncoder.INSTANCE.write${sign}${type}Array(proto.${field.name}, bytes, offset);"
		} else {
			return """\
				|for (val element : proto.${field.name}) {
				|			byte[] ${field.name}Bytes = ${findEncoderImportForType(field.rawPrefix)}${field.type}Encoder.INSTANCE.encode(element);
				|			offset += ${field.name}Bytes.length;
				|		}\
				""".stripMargin()
		}
	}
}

static String mapSuplaTypeToJava(type) {
	type = type.toLowerCase()
	if (type == "_supla_int_t" || type == "int") {
		return "int"
	}
	if (type == "char" || type == "byte") {
		return "byte"
	}
	if (type == "_supla_int16_t" || type == "short") {
		return "short"
	}
	if (type == "_supla_int64_t" || type == "long") {
		return "long"
	}
	return null
}

static boolean isPrimitiveType(type) {
	type = type.toLowerCase()
	return (type == "_supla_int_t"
		|| type == "int"
		|| type == "char"
		|| type == "byte"
		|| type == "_supla_int16_t"
		|| type == "short"
		|| type == "_supla_int64_t"
		|| type == "long")
}

static String findEncoderImportForType(rawPrefix) {
	if (rawPrefix == "T") {
		return "pl.grzeslowski.jsupla.protocol.api.encoders."
	}
	def prefix = rawPrefix.substring(1).toLowerCase()
	return "pl.grzeslowski.jsupla.protocol.api.encoders.${prefix}."
}

static String findEncoder(struct) {
	def encoderImport = findEncoderImportForType(struct.prefix)
	def protoClass = encoderImport.replaceAll(".encoders.", ".structs.") + struct.name
	def encoderClass = encoderImport + struct.name + "Encoder"
	return """\
		|		if (${protoClass}.class.isAssignableFrom(proto)) {
        |    		return (Encoder<T>) ${encoderClass}.INSTANCE; 
        |		}""".stripMargin()
}

tasks.named('sourcesJar') {
	dependsOn tasks.named('encodersGenerator'),
		tasks.named('encoderFactoryGenerator')
}