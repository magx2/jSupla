import groovy.json.JsonSlurper

import java.nio.file.Files
import java.nio.file.Path
import java.time.ZonedDateTime
import java.util.stream.Collectors

import static java.util.stream.Collectors.joining

task encodersGenerator {
	group = 'jSupla'
	inputs.file new File(project.file("build/parser"), "proto.h.json")
	outputs.dir project.file("build/generated/sources/jsupla/main/java/pl/grzeslowski/jsupla/protocol/")
	doLast {
		def jsonFile = new File(project.file("build/parser"), "proto.h.json")
		if (!jsonFile.exists()) {
			throw new IOException("File ${jsonFile.absolutePath} does not exists!")
		}

		def jsonSlurper = new JsonSlurper()
		def structs = (jsonSlurper.parse(jsonFile) as List)

		def generatedSourceRoot = project.file("build/generated/sources/jsupla/main/java/pl/grzeslowski/jsupla/protocol/").toPath()
		Files.createDirectories(generatedSourceRoot)

		structs
			.stream()
			.sorted { a, b -> a.rawName.compareTo(b.rawName) }
			.forEach { generateEncoder(it, generatedSourceRoot) }
	}
}
encodersGenerator.dependsOn "parseProtoh"
compileJava.dependsOn "encodersGenerator"

task encoderFactoryGenerator {
	group = 'jSupla'
	inputs.file new File(project.file("build/parser"), "proto.h.json")
	outputs.file project.file("build/generated/sources/jsupla/main/java/pl/grzeslowski/jsupla/protocol/api/encoders/EncoderFactoryImpl.java")
	doLast {
		def jsonFile = new File(project.file("build/parser"), "proto.h.json")
		if (!jsonFile.exists()) {
			throw new IOException("File ${jsonFile.absolutePath} does not exists!")
		}

		def jsonSlurper = new JsonSlurper()
		def structs = (jsonSlurper.parse(jsonFile) as List)

		def imports = [
			"import pl.grzeslowski.jsupla.protocol.api.types.ProtoWithSize;"
		].stream().collect(joining("\n"))
		def findEncoder = structs.stream()
			.sorted { a, b -> a.rawName.compareTo(b.rawName) }
			.map { findEncoder(it) }
			.collect(joining("\n"))

		def content = """\
			|package pl.grzeslowski.jsupla.protocol.api.encoders;
			|
			|$imports
			|
			|public class EncoderFactoryImpl implements EncoderFactory {
    		|	public static final EncoderFactoryImpl INSTANCE = new EncoderFactoryImpl();
			|
			|	@SuppressWarnings("unchecked")
    		|	@Override
    		|	public <T extends ProtoWithSize> Encoder<T> getEncoder(final Class<T> proto) {
			|$findEncoder
			|
			|		throw new IllegalArgumentException("Can't find encoder for class " + proto);
			|	}
			|}
			|""".stripMargin()

		def encoderFactoryImpl = project.file("build/generated/sources/jsupla/main/java/pl/grzeslowski/jsupla/protocol/api/encoders/EncoderFactoryImpl.java").toPath()
		Files.createDirectories(encoderFactoryImpl.parent)

		encoderFactoryImpl.write(content)
	}
}
encoderFactoryGenerator.dependsOn "encodersGenerator"
compileJava.dependsOn "encoderFactoryGenerator"

void generateEncoder(struct, Path generatedSourceRoot) {
	def path = "api/encoders"
	def javaName = (struct.overrideName ?: struct.name) + "Encoder"
	def prefix = struct.prefix
	if (prefix != "T") {
		path += "/" + prefix.toLowerCase().substring(1)
	}
	def toWrite = generatedSourceRoot.resolve(path).resolve(javaName + ".java")
	def sourcesPath = project.file("src/main/java/pl/grzeslowski/jsupla/protocol/").toPath().resolve(path).resolve(javaName + ".java")
	if (Files.exists(sourcesPath)) {
		logger.warn("Encoder {} already exists, ignoring...", sourcesPath.toFile().path)
		return
	}

	def classPackage = "pl.grzeslowski.jsupla.protocol.${path.replaceAll("/", ".")}"
	def imports = new TreeSet<>([
		"import lombok.val",
		"import pl.grzeslowski.jsupla.protocol.api.encoders.PrimitiveEncoder",
		"import static pl.grzeslowski.jsupla.protocol.api.JavaConsts.*",
		"import " + classPackage.replaceAll("encoders", "structs") + "." + (struct.overrideName ?: struct.name),
		"import static pl.grzeslowski.jsupla.protocol.api.consts.ProtoConsts.*",
	])
	def implementClass = findImplementClass(struct)
	def structName = (struct.overrideName ?: struct.name)
	def parse
	String fields = struct.fields
		.stream()
		.map { field -> "\t\t${parseField(field)}" }
		.collect(joining("\n"))
	parse = """\
        	|$fields""".stripMargin()

	def content = """\
		|package $classPackage;
		|
		|${String.join(";\n|", imports)};
		|
		|@javax.annotation.Generated(value="Struct original name: ${struct.rawName}", date = "${ZonedDateTime.now()}")
		|@lombok.NoArgsConstructor(access = lombok.AccessLevel.PRIVATE)
		|public class ${javaName} implements ${implementClass}<${structName}> {
		|	public static final ${javaName} INSTANCE = new ${javaName}();
		|
		|   @Override
    	|	public int encode($structName proto, byte[] bytes, int offset) {
		|	var startingOffset = offset;
		|$parse
		|		
    	|	    return offset - startingOffset;
    	|	}
		|}
		|""".stripMargin()

	Files.createDirectories(toWrite.parent)
	toWrite.write(content)
}

static String findImplementClass(struct) {
	def prefix = struct.prefix
	if (prefix == "T") {
		return "pl.grzeslowski.jsupla.protocol.api.encoders.ProtoWithSizeEncoder"
	}
	prefix = prefix.toString().substring(1).toLowerCase()

	def implementClass = "pl.grzeslowski.jsupla.protocol.api.encoders.${prefix}."
	for (def letter : prefix) {
		def s
		if (letter == "c") {
			implementClass += "Client"
		} else if (letter == "s") {
			implementClass += "Server"
		} else if (letter == "d") {
			implementClass += "Device"
		} else {
			throw new IllegalArgumentException("[encoders] Unknown letter [$letter] !")
		}
	}
	return implementClass + "Encoder"
}

static String parseField(field, boolean addOffset = true) {
	if (field.originalClassName == "UnionField") {
		def parsing = field.fields.stream()
			.map { "if(proto.${it.name}() != null) { ${parseField(it, false)} }" }
			.collect(joining(" else "))
		def offset = field.fields
			.stream()
			.map { pojoGeneratorFindSize(it, true) }
			.collect(Collectors.joining("\n\t\t\t,"))
		return "// UNION START\n" +
			parsing +
			"\noffset += pl.grzeslowski.jsupla.protocol.api.JavaConsts.unionSize($offset);" +
			"\n// UNION END"
	} else if (!field.array) {
		if (isPrimitiveType(field.type)) {
			def sign = field.unsigned ? "Unsigned" : ""
			def type = mapSuplaTypeToJava(field.type).capitalize()
			def encode = ""
			if(addOffset) {
				encode += "offset += "
			}
			encode+="PrimitiveEncoder.INSTANCE.write${sign}${type}(proto.${field.name}(), bytes, offset);"
			return encode
		} else {
			def encode = ""
			if (addOffset) {
				encode += "offset += "
			}
			 encode += "${findEncoderImportForType(field.rawPrefix)}${field.type}Encoder.INSTANCE.encode(proto.${field.name}(), bytes, offset);"
			return encode
		}
	} else {
		if (isPrimitiveType(field.type)) {
			def sign = field.unsigned ? "Unsigned" : ""
			def type = mapSuplaTypeToJava(field.type).capitalize()
			def encode = "PrimitiveEncoder.INSTANCE.write${sign}${type}Array(proto.${field.name}(), bytes, offset);"
			if (addOffset) {
				encode = "offset += " + encode
			}
			return encode
		} else {
			def encode = "for (val element : proto.${field.name}()) {\n"
			if (addOffset) {
				encode += "offset += "
			}
			encode += "${findEncoderImportForType(field.rawPrefix)}${field.type}Encoder.INSTANCE.encode(element, bytes, offset);"
			encode += "}"
			return encode
		}
	}
}

// copied from pojoGenerator
static String pojoGeneratorFindSize(field, union) {
	def type = field.type.toLowerCase()
	if (field.array) {
		def xSize = pojoGeneratorMapSimpleType(type)
		if (xSize.startsWith("UNKNOWN")) {
			return "arraySize(" + field.name + ")"
		} else {
			if (field.arraySize) {
				return "(int) ${field.arraySize} * ${xSize}"
			} else {
				return "${field.name}.length * ${xSize}"
			}
		}
	} else if (field.unsigned) {
		if (type == "byte") {
			return "CHAR_SIZE"
		} else if (type == "short") {
			return "SHORT_SIZE"
		} else if (type == "int" || type == "integer") {
			return "INT_SIZE"
		} else if (type == "char") {
			return "CHAR_SIZE"
		} else if (field.type == "long") {
			return "LONG_SIZE"
		} else {
			throw new IllegalArgumentException("Unknown unsigned type: " + type)
		}
	} else {
		def finalType = pojoGeneratorMapSimpleType(pojoGeneratorMapSuplaTypeToJava(field))
		if (finalType.startsWith("UNKNOWN")) {
			if (union) {
				finalType = "(proto.${field.name}()!= null ? proto.${field.name}().protoSize() : ${pojoGeneratorMapSuplaTypeToJava(field)}.SIZE)"
			} else {
				finalType = field.name + ".protoSize()"
			}
		}
		return finalType
	}
}
// copied from pojoGenerator
static String pojoGeneratorMapSuplaTypeToJava(field) {
	def array = field.array ? "[]" : ""
	def lowerType = field.type.toLowerCase()
	if (field.unsigned) {
		if (lowerType == "int" || lowerType == "integer") {
			return pojoGeneratorMatchType("long", field.type, array)
		}
		if (lowerType == "char" || lowerType == "byte") {
			return pojoGeneratorMatchType("short", field.type, array)
		}
		if (lowerType == "short") {
			return pojoGeneratorMatchType("int", field.type, array)
		}
		if (lowerType == "long") {
			return pojoGeneratorMatchType("java.math.BigInteger", field.type, array)
		}
	} else {
		if (lowerType == "int" || lowerType == "integer") {
			return pojoGeneratorMatchType("int", field.type, array)
		}
		if (lowerType == "short") {
			return pojoGeneratorMatchType("short", field.type, array)
		}
		if (lowerType == "long") {
			return pojoGeneratorMatchType("long", field.type, array)
		}
		if (lowerType == "char" || lowerType == "byte") {
			return pojoGeneratorMatchType("byte", field.type, array)
		}
	}
	return pojoGeneratorFindImportClass(field) + field.type + array
}

static String pojoGeneratorMatchType(String newType, String originalType, String array) {
	if (originalType == originalType.toLowerCase()) {
		return newType + array
	}
	if (newType == "int" && originalType == "Short") {
		return "Integer" + array
	}
	if (newType == "int" && originalType == "Int") {
		return "Integer" + array
	}
	if (array) {
		return newType + array
	} else {
		return newType.capitalize() + array
	}
}

static String pojoGeneratorMapSimpleType(String type) {
	type = type.toLowerCase()
	if (type == "int" || type == "integer") {
		return "INT_SIZE"
	} else if (type == "char" || type == "byte") {
		return "BYTE_SIZE"
	} else if (type == "short") {
		return "SHORT_SIZE"
	} else if (type == "long") {
		return "LONG_SIZE"
	}
	return "UNKNOWN_" + type
}

static String pojoGeneratorFindImportClass(field) {
	if (field.rawPrefix == "T") {
		return "pl.grzeslowski.jsupla.protocol.api.structs."
	}

	def prefix = field.rawPrefix.toString().substring(1).toLowerCase()
	return "pl.grzeslowski.jsupla.protocol.api.structs.${prefix}."
}

static String mapSuplaTypeToJava(type) {
	type = type.toLowerCase()
	if (type == "_supla_int_t" || type == "int") {
		return "int"
	}
	if (type == "char" || type == "byte") {
		return "byte"
	}
	if (type == "_supla_int16_t" || type == "short") {
		return "short"
	}
	if (type == "_supla_int64_t" || type == "long") {
		return "long"
	}
	return null
}

static boolean isPrimitiveType(type) {
	type = type.toLowerCase()
	return (type == "_supla_int_t"
		|| type == "int"
		|| type == "char"
		|| type == "byte"
		|| type == "_supla_int16_t"
		|| type == "short"
		|| type == "_supla_int64_t"
		|| type == "long")
}

static String findEncoderImportForType(rawPrefix) {
	if (rawPrefix == "T") {
		return "pl.grzeslowski.jsupla.protocol.api.encoders."
	}
	def prefix = rawPrefix.substring(1).toLowerCase()
	return "pl.grzeslowski.jsupla.protocol.api.encoders.${prefix}."
}

static String findEncoder(struct) {
	def encoderImport = findEncoderImportForType(struct.prefix)
	def protoClass = encoderImport.replaceAll(".encoders.", ".structs.") + (struct.overrideName ?: struct.name)
	def encoderClass = encoderImport + (struct.overrideName ?: struct.name) + "Encoder"
	return """\
		|		if (${protoClass}.class.isAssignableFrom(proto)) {
        |    		return (Encoder<T>) ${encoderClass}.INSTANCE; 
        |		}""".stripMargin()
}

tasks.named('sourcesJar') {
	dependsOn tasks.named('encodersGenerator'),
		tasks.named('encoderFactoryGenerator')
}