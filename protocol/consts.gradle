import groovy.json.JsonSlurper

import java.nio.file.Files
import java.nio.file.Path
import java.time.ZonedDateTime
import java.util.stream.Collectors
import java.util.stream.Stream

List overrides = [
	[name: "SUPLA_MAX_DATA_SIZE", value: "3264"],
	[name: "SPROTO_WITHOUT_OUT_BUFFER", value: "true"],
	[name: "SUPLA_CHANNELMAXCOUNT", value: "128"],
	[name: "SUPLA_CHANNELEXTENDEDVALUE_SIZE", value: "1024"],
	[name: "EM_MEASUREMENT_COUNT", value: "5"],
	[name: "PROTO_ICACHE_FLASH", value: "true"],
]

class Const {
	String name
	String prefix
	Closure<Boolean> filter = { String s -> s.startsWith(prefix) }
	String extraJavaCode
	Object options = []
}

def consts = [
	[
		name  : "ResultCode",
		prefix: "SUPLA_RESULTCODE_",] as Const,
	[
		name         : "RgbwBitFunction",
		prefix       : "SUPLA_RGBW_BIT_FUNC_",
		extraJavaCode: """\
		|   public static java.util.Set<RgbwBitFunction> findByMask(long value) {
		|   return java.util.Arrays.stream(RgbwBitFunction.values())
		|   	.filter(flag -> (value & flag.value) != 0)
		|   	.collect(java.util.stream.Collectors.toCollection(() -> java.util.EnumSet.noneOf(RgbwBitFunction.class)));
		|   }""".stripMargin()] as Const,
	[
		name  : "ChannelType",
		prefix: "SUPLA_CHANNELTYPE_",
		filter: { name ->
			name.startsWith("SUPLA_CHANNELTYPE_") ||
				name.startsWith("EV_TYPE") ||
				name.startsWith("SUBV_TYPE_") ||
				name.startsWith("CALCFG_TYPE_")
		}] as Const,
	[
		name         : "ChannelFlag",
		prefix       : "SUPLA_CHANNEL_FLAG_",
		extraJavaCode: """\
		|   public static java.util.Set<ChannelFlag> findByMask(long value) {
		|   return java.util.Arrays.stream(ChannelFlag.values())
		|   	.filter(flag -> (value & flag.value) != 0)
		|   	.collect(java.util.stream.Collectors.toCollection(() -> java.util.EnumSet.noneOf(ChannelFlag.class)));
		|   }""".stripMargin()] as Const,
	[
		name  : "ChannelFunction",
		prefix: "SUPLA_CHANNELFNC_"] as Const,
	[
		name         : "HvacFlag",
		prefix       : "SUPLA_HVAC_VALUE_FLAG_",
		extraJavaCode: """\
		|   public static java.util.Set<HvacFlag> findByMask(long value) {
		|   	return java.util.Arrays.stream(HvacFlag.values())
		|   		.filter(flag -> (value & flag.value) != 0)
		|   		.collect(java.util.stream.Collectors.toCollection(() -> java.util.EnumSet.noneOf(HvacFlag.class)));
		|   }
		|
		|   public static long toMask(java.util.Set<HvacFlag> flags) {
		|   	return flags.stream()
		|   		.mapToLong(flag -> flag.value)
		|   		.reduce(0, (a, b) -> a | b);
		|   }""".stripMargin(),
		options      : [valueType: "long"]] as Const,
	[
		name  : "HvacMode",
		prefix: "SUPLA_HVAC_MODE_"] as Const,
	[
		name  : "ThermostatCommand",
		prefix: "SUPLA_THERMOSTAT_CMD_"] as Const,
	[
		name         : "ThermostatValueFlag",
		prefix       : "SUPLA_THERMOSTAT_VALUE_FLAG_",
		extraJavaCode: """\
		|   public static java.util.Set<ThermostatValueFlag> findByMask(int value) {
		|   return java.util.Arrays.stream(ThermostatValueFlag.values())
		|   	.filter(flag -> (value & flag.value) != 0)
		|   	.collect(java.util.stream.Collectors.toCollection(() -> java.util.EnumSet.noneOf(ThermostatValueFlag.class)));
		|   }
		|
		|   public static int toMask(java.util.Set<ThermostatValueFlag> flags) {
		|   	return flags.stream()
		|   		.mapToInt(flag -> flag.value)
		|   		.reduce(0, (a, b) -> a | b);
		|   }""".stripMargin()] as Const,
	[
		name  : "ThermostatField",
		prefix: "THERMOSTAT_FIELD_"] as Const,
	[
		name  : "MeterCounterType",
		prefix: "SUPLA_GENERAL_PURPOSE_METER_COUNTER_TYPE_"] as Const,
	[
		name  : "MeterChartType",
		prefix: "SUPLA_GENERAL_PURPOSE_METER_CHART_TYPE_"] as Const,
	[
		name  : "EvType",
		prefix: "EV_TYPE_"] as Const,
	[
		name  : "SubvType",
		prefix: "SUBV_TYPE_"] as Const,
	[
		name  : "Mfr",
		prefix: "SUPLA_MFR_"] as Const,
	[
		name  : "SuplaEvent",
		prefix: "SUPLA_EVENT_"] as Const,
	[
		name  : "SuplaResult",
		prefix: "SUPLA_RESULT_"] as Const,
	[
		name  : "SuplaBit",
		prefix: "SUPLA_BIT_"] as Const,
	[
		name  : "ModbusRole",
		prefix: "MODBUS_ROLE_"] as Const,
	[
		name  : "ModbusSerialMode",
		prefix: "MODBUS_SERIAL_MODE_"] as Const,
	[
		name  : "ModbusNetworkMode",
		prefix: "MODBUS_NETWORK_MODE_"] as Const,
	[
		name  : "FirmwareUpdatePolicy",
		prefix: "SUPLA_FIRMWARE_UPDATE_POLICY_"] as Const,
	[
		name  : "StatusLed",
		prefix: "SUPLA_DEVCFG_STATUS_LED_"] as Const,
	[
		name  : "LastConnectionResetCause",
		prefix: "SUPLA_LASTCONNECTIONRESETCAUSE_"] as Const,
	[
		name  : "BitFunction",
		prefix: "SUPLA_BIT_FUNC_",
		extraJavaCode: """\
		|   public static java.util.Set<BitFunction> findByMask(int value) {
		|   return java.util.Arrays.stream(BitFunction.values())
		|   	.filter(flag -> (value & flag.value) != 0)
		|   	.collect(java.util.stream.Collectors.toCollection(() -> java.util.EnumSet.noneOf(BitFunction.class)));
		|   }""".stripMargin()] as Const,
	[
		name  : "DeviceFlag",
		prefix: "SUPLA_DEVICE_FLAG_",
		extraJavaCode: """\
		|   public static java.util.Set<DeviceFlag> findByMask(int value) {
		|   return java.util.Arrays.stream(DeviceFlag.values())
		|   	.filter(flag -> (value & flag.value) != 0)
		|   	.collect(java.util.stream.Collectors.toCollection(() -> java.util.EnumSet.noneOf(DeviceFlag.class)));
		|   }
		|
		|   public static int toMask(java.util.Set<DeviceFlag> flags) {
		|   	return flags.stream()
		|   		.mapToInt(flag -> flag.value)
		|   		.reduce(0, (a, b) -> a | b);
		|   }""".stripMargin()] as Const,
	[
		name  : "ChannelStateField",
		prefix: "SUPLA_CHANNELSTATE_FIELD_",
		extraJavaCode: """\
		|   public static java.util.Set<ChannelStateField> findByMask(int value) {
		|   return java.util.Arrays.stream(ChannelStateField.values())
		|   	.filter(flag -> (value & flag.value) != 0)
		|   	.collect(java.util.stream.Collectors.toCollection(() -> java.util.EnumSet.noneOf(ChannelStateField.class)));
		|   }""".stripMargin()] as Const,
	[
		name         : "DeviceConfigField",
		prefix       : "SUPLA_DEVICE_CONFIG_FIELD_",
		options      : [valueType: "long"],
		extraJavaCode: """\
		|   public static java.util.Set<DeviceConfigField> findByMask(long value) {
		|   return java.util.Arrays.stream(DeviceConfigField.values())
		|   	.filter(flag -> (value & flag.value) != 0)
		|   	.collect(java.util.stream.Collectors.toCollection(() -> java.util.EnumSet.noneOf(DeviceConfigField.class)));
		|   }""".stripMargin()] as Const,
]
consts.each { constDef ->
	def taskName = "${constDef.name}CodeGenerator"
	//noinspection GroovyAssignabilityCheck
	task "$taskName" {
		group = 'jSupla'
		inputs.file new File(project.file("build/parser"), "consts.json")
		outputs.file project.file("build/generated/sources/jsupla/main/java/pl/grzeslowski/jsupla/protocol/api/${constDef.name}.java")
		doLast {
			def jsonFile = new File(project.file("build/parser"), "consts.json")
			if (!jsonFile.exists()) {
				throw new IOException("File ${jsonFile.absolutePath} does not exists!")
			}

			def jsonSlurper = new JsonSlurper()
			def codes = (jsonSlurper.parse(jsonFile) as List)
				.stream()
				.filter { constDef.filter(it.name) }
				.map {
					def javaDoc = ""
					if (it.javaDoc) {
						javaDoc = "/** ${it.javaDoc} */\n\t"
							.replaceAll("&", "&amp;")
							.replaceAll("&", "&amp;")
							.replaceAll("<", "&#60;")
							.replaceAll(">", "&#62;")
					}
					def deprecated = it?.javaDoc?.contains("DEPRECATED") ? "\n\t@Deprecated" : ""
					"$javaDoc$deprecated ${it.name}(${mapValue(it.value)})"
				}
				.collect(Collectors.joining(",\n\t"))

			def codePath = project.file("build/generated/sources/jsupla/main/java/pl/grzeslowski/jsupla/protocol/api/${constDef.name}.java").toPath()
			Files.createDirectories(codePath.parent)

			def type = constDef.options.valueType ?: "int"

			codePath.write("""\
			|package pl.grzeslowski.jsupla.protocol.api;
			|
			|@javax.annotation.Generated(value="Const from proto.h", date = "${ZonedDateTime.now()}", comments = "generated by ${constDef.name}CodeGenerator from ProtoConsts.h")
			|@lombok.Getter @lombok.RequiredArgsConstructor
			|public enum ${constDef.name} {
			|	$codes
			|	;
			|	private final $type value;
			|
			|	public static java.util.Optional<${constDef.name}> findByValue($type value) {
    		|    return java.util.Arrays.stream(values())
    		|        .filter(type -> type.value == value)
    		|        .findAny();
    		|	}
			|	${constDef.extraJavaCode ?: ''}
			|}""".stripMargin())
		}
		tasks[taskName].dependsOn "parseProtoh"
		compileJava.dependsOn tasks[taskName]
		tasks.spotlessJava.dependsOn tasks[taskName]
		tasks.named('sourcesJar') {
			dependsOn tasks.named(taskName)
		}
	}
}

task constsGenerator {
	group = 'jSupla'
	inputs.file new File(project.file("build/parser"), "consts.json")
	outputs.file project.file("build/generated/sources/jsupla/main/java/pl/grzeslowski/jsupla/protocol/api/consts/ProtoConsts.java")
	doLast {
		def jsonFile = new File(project.file("build/parser"), "consts.json")
		if (!jsonFile.exists()) {
			throw new IOException("File ${jsonFile.absolutePath} does not exists!")
		}

		def jsonSlurper = new JsonSlurper()
		def genericConsts = (jsonSlurper.parse(jsonFile) as List)
			.stream()
			.filter { !predefined(it, overrides) }
			.toList()

		def protoConsts = project.file("build/generated/sources/jsupla/main/java/pl/grzeslowski/jsupla/protocol/api/consts/ProtoConsts.java").toPath()
		Files.createDirectories(protoConsts.parent)

		def java = """\
			|package pl.grzeslowski.jsupla.protocol.api.consts;
			|
			|@javax.annotation.Generated(value="Const from proto.h", date = "${ZonedDateTime.now()}", comments = "generated from ProtoConsts.h")
			|public interface ProtoConsts {
			|	public static final byte[] SUPLA_TAG = new byte[]{83, 85, 80, 76, 65};
			|""".stripMargin()
		java += Stream.concat(genericConsts.stream(), overrides.stream())
			.filter { !it.name.startsWith("_") }
			.filter { it.name != "timeval" }
			.filter { it.name != "SUPLA_CHANNELEXTENDEDVALUE_PACK_MAXDATASIZE" }
			.filter { consts.stream().noneMatch { constDef -> constDef.filter(it.name) } }
			.map { generateConst(it, genericConsts) }
			.collect(Collectors.joining("\n\t"))
		java += """
			|	public static final int SUPLA_CHANNELEXTENDEDVALUE_PACK_MAXDATASIZE = SUPLA_MAX_DATA_SIZE - 50;
			|}""".stripMargin()

		protoConsts.write(java)
	}
}
constsGenerator.dependsOn "parseProtoh"
compileJava.dependsOn "constsGenerator"

task callTypesGenerator {
	group = 'jSupla'
	inputs.file new File(project.file("build/parser"), "consts.json")
	outputs.dir project.file("build/generated/sources/jsupla/main/java/pl/grzeslowski/jsupla/protocol/api/calltypes/")
	doLast {
		def jsonFile = new File(project.file("build/parser"), "consts.json")
		if (!jsonFile.exists()) {
			throw new IOException("File ${jsonFile.absolutePath} does not exists!")
		}

		def jsonSlurper = new JsonSlurper()
		def callTypes = (jsonSlurper.parse(jsonFile) as List)
			.stream()
			.filter { isCallType(it.name) }
			.toList()

		def callTypesFolder = project.file("build/generated/sources/jsupla/main/java/pl/grzeslowski/jsupla/protocol/api/calltypes/").toPath()
		Files.createDirectories(callTypesFolder)

		buildCallType('ClientServer', "SUPLA_CS_", callTypesFolder, callTypes)
		buildCallType('ClientServerDevice', "SUPLA_CSD_", callTypesFolder, callTypes)
		buildCallType('DeviceClientServer', "SUPLA_DCS_", callTypesFolder, callTypes)
		buildCallType('DeviceServer', "SUPLA_DS_", callTypesFolder, callTypes)
		buildCallType('DeviceServerClient', "SUPLA_DSC_", callTypesFolder, callTypes)
		buildCallType('ServerClient', "SUPLA_SC_", callTypesFolder, callTypes)
		buildCallType('ServerClientDevice', "SUPLA_SCD_", callTypesFolder, callTypes)
		buildCallType('ServerClientServer', "SUPLA_SCS_", callTypesFolder, callTypes)
		buildCallType('ServerDevice', "SUPLA_SD_", callTypesFolder, callTypes)
		buildCallType('ServerDeviceClient', "SUPLA_SDC_", callTypesFolder, callTypes)
		buildCallType('ServerDeviceServer', "SUPLA_SDS_", callTypesFolder, callTypes)
	}
}
callTypesGenerator.dependsOn "parseProtoh"
compileJava.dependsOn "callTypesGenerator"

static boolean isCallType(String name) {
	return name.startsWith("SUPLA_CS_") ||
		name.startsWith("SUPLA_CSD_") ||
		name.startsWith("SUPLA_DCS_") ||
		name.startsWith("SUPLA_DS_") ||
		name.startsWith("SUPLA_DSC_") ||
		name.startsWith("SUPLA_SC_") ||
		name.startsWith("SUPLA_SCD_") ||
		name.startsWith("SUPLA_SCS_") ||
		name.startsWith("SUPLA_SD_") ||
		name.startsWith("SUPLA_SDC_") ||
		name.startsWith("SUPLA_SDS_")
}

static void buildCallType(String callTypeName, String callTypePrefix, Path callTypesFolder, consts) {
	def className = callTypeName + "CallType"
	def fileName = className + ".java"
	def fields = consts.stream()
		.filter { it.name.startsWith(callTypePrefix) }
		.map {
			def javaDoc = ""
			if (it.javaDoc) {
				javaDoc = "/** ${it.javaDoc} */\n\t"
					.replaceAll("&", "&amp;")
					.replaceAll("<", "&#60;")
					.replaceAll(">", "&#62;")
					.replaceAll("@", "&#64;")
			}
			"$javaDoc${it.name}(${it.value})"
		}
		.collect(Collectors.joining(",\n\t"))
	def content = """\
		|package pl.grzeslowski.jsupla.protocol.api.calltypes;
		|
		|@lombok.Getter
		|@lombok.RequiredArgsConstructor
		|@javax.annotation.Generated(value="Prefix '$callTypePrefix'", date = "${ZonedDateTime.now()}")
		|public enum ${className} implements CallType {
		|	$fields;
		|	private final int value;
		|}""".stripMargin()

	callTypesFolder.resolve(fileName).write(content)
}

static String generateConst(constObj, List consts) {
	def value = consts
		.stream()
		.filter { it.name == constObj.value }
		.findAny()
	if (value.isPresent()) {
		def javaDoc = ""
		if (value.get().javaDoc) {
			javaDoc = "/** ${value.get().javaDoc} */\n\t"
				.replaceAll("&", "&amp;")
				.replaceAll("<", "&#60;")
				.replaceAll(">", "&#62;")
				.replaceAll("@", "&#64;")
		}
		def type = findType(value.get().value)
		return "${javaDoc}public static final $type ${constObj.name} = ${value.get().name};"
	}

	def javaDoc = ""
	if (constObj.javaDoc) {
		javaDoc = "/** ${constObj.javaDoc} */\n\t"
			.replaceAll("&", "&amp;")
			.replaceAll("<", "&#60;")
			.replaceAll(">", "&#62;")
			.replaceAll("@", "&#64;")
	}
	def type = findType(constObj.value)
	return "${javaDoc}public static final $type ${constObj.name} = ${mapValue(constObj.value)};"
}

static String mapValue(String value) {
	if (value == null) {
		return "true"
	}
	if (value == "\\") {
		return '"' + "\\\\" + '"'
	}
	if (value.matches(/\(1ULL << \d+\)/)) {
		return value.replaceAll(/(1ULL) << (\d+)/, '1L << $2')
	}
	if (value.matches(/\(1 << \d+\)/)) {
		return value.replaceAll(/(1) << (\d+)/, '1 << $2')
	}
	if (value.startsWith("0x")) {
		return value
	}
	try {
		Eval.me(value)
		return value
	} catch (Exception ignore) {
	}
	try {
		Integer.parseInt(value)
		return value
	} catch (NumberFormatException ignored) {
		return '"' + value + '"'
	}
}

static String findType(String value) {
	if (value == null) {
		return "boolean"
	}
	if (value.matches(/\(1ULL << \d+\)/)) {
		return "long"
	}
	if (value.contains("<<")) {
		return "int"
	}
	if (value.startsWith("0x")) {
		return "int"
	}
	try {
		def eval = Eval.me(value)
		def clazz = eval.class
		if (clazz == Integer.class) {
			return "int"
		}
		if (clazz == String.class) {
			return "String"
		}
		if (clazz == Long.class) {
			return "long"
		}
		return clazz.simpleName
	} catch (Exception ignore) {
	}
	try {
		Integer.parseInt(value)
		return "int"
	} catch (NumberFormatException ignored) {
		return "String"
	}
}

static boolean predefined(constObj, List overrides) {
	overrides.stream()
		.map { it.name }
		.anyMatch { it == constObj.name }
}

tasks.named('sourcesJar') {
	dependsOn tasks.named('callTypesGenerator'),
		tasks.named('constsGenerator')
}