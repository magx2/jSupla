import groovy.json.JsonSlurper

import java.nio.file.Files
import java.nio.file.Path
import java.time.ZonedDateTime
import java.util.stream.Collectors
import java.util.stream.Stream

List overrides = [
	[name: "SUPLA_MAX_DATA_SIZE", value: "3264"],
	[name: "SPROTO_WITHOUT_OUT_BUFFER", value: "true"],
	[name: "SUPLA_CHANNELMAXCOUNT", value: "128"],
	[name: "SUPLA_CHANNELEXTENDEDVALUE_SIZE", value: "1024"],
	[name: "EM_MEASUREMENT_COUNT", value: "5"],
	[name: "PROTO_ICACHE_FLASH", value: "true"],
]

task constsGenerator {
	doLast {
		def jsonFile = new File(project.file("build/parser"), "consts.json")
		if (!jsonFile.exists()) {
			throw new IOException("File ${jsonFile.absolutePath} does not exists!")
		}

		def jsonSlurper = new JsonSlurper()
		def consts = (jsonSlurper.parse(jsonFile) as List)
			.stream()
			.filter { !predefined(it, overrides) }
			.toList()

		def protoConsts = project.file("build/generated/sources/jsupla/java/main/pl/grzeslowski/jsupla/protocol/api/consts/ProtoConsts.java").toPath()
		Files.createDirectories(protoConsts.parent)

		def java = """\
			|package pl.grzeslowski.jsupla.protocol.api.consts;
			|
			|@javax.annotation.Generated(value="Const from proto.h", date = "${ZonedDateTime.now()}", comments = "generated from ProtoConsts.h")
			|public interface ProtoConsts {
			|	public static final byte[] SUPLA_TAG = new byte[]{83, 85, 80, 76, 65};
			|""".stripMargin()
		java += Stream.concat(consts.stream(), overrides.stream())
			.filter { !it.name.startsWith("_") }
			.filter { it.name != "timeval" }
			.filter { !isCallType(it.name) }
			.filter { !isResultCode(it.name) }
			.map { generateConst(it, consts) }
			.collect(Collectors.joining("\n\t"))
		java += "\n}"

		protoConsts.write(java)
	}
}
constsGenerator.dependsOn "parseProtoh"
compileJava.dependsOn "constsGenerator"

task callTypesGenerator {
	doLast {
		def jsonFile = new File(project.file("build/parser"), "consts.json")
		if (!jsonFile.exists()) {
			throw new IOException("File ${jsonFile.absolutePath} does not exists!")
		}

		def jsonSlurper = new JsonSlurper()
		def consts = (jsonSlurper.parse(jsonFile) as List)
			.stream()
			.filter { isCallType(it.name) }
			.toList()

		def callTypesFolder = project.file("build/generated/sources/jsupla/java/main/pl/grzeslowski/jsupla/protocol/api/calltypes/").toPath()
		Files.createDirectories(callTypesFolder)

		buildCallType('ClientServer', "SUPLA_CS_", callTypesFolder, consts)
		buildCallType('DeviceClientServer', "SUPLA_DCS_", callTypesFolder, consts)
		buildCallType('DeviceServer', "SUPLA_DS_", callTypesFolder, consts)
		buildCallType('ServerClient', "SUPLA_SC_", callTypesFolder, consts)
		buildCallType('ServerDevice', "SUPLA_SD_", callTypesFolder, consts)
		buildCallType('ServerDeviceClient', "SUPLA_SDC_", callTypesFolder, consts)
	}
}
callTypesGenerator.dependsOn "parseProtoh"
compileJava.dependsOn "callTypesGenerator"

task resultCodeGenerator {
	doLast {
		def jsonFile = new File(project.file("build/parser"), "consts.json")
		if (!jsonFile.exists()) {
			throw new IOException("File ${jsonFile.absolutePath} does not exists!")
		}

		def jsonSlurper = new JsonSlurper()
		def resultCodes = (jsonSlurper.parse(jsonFile) as List)
			.stream()
			.filter { isResultCode(it.name) }
			.map {
				def javaDoc = ""
				if (it.javaDoc) {
					javaDoc = "/** ${it.javaDoc} */\n\t"
				}
				"$javaDoc${it.name}(${it.value})"
			}
			.collect(Collectors.joining(",\n\t"))

		def resultCodePath = project.file("build/generated/sources/jsupla/java/main/pl/grzeslowski/jsupla/protocol/api/ResultCode.java").toPath()
		Files.createDirectories(resultCodePath.parent)

		resultCodePath.write("""\
			|package pl.grzeslowski.jsupla.protocol.api;
			|
			|@javax.annotation.Generated(value="Const from proto.h", date = "${ZonedDateTime.now()}", comments = "generated from ProtoConsts.h")
			|@lombok.Getter @lombok.RequiredArgsConstructor
			|public enum ResultCode {
			|	$resultCodes
			|	;
			|	private final int value;
			|}""".stripMargin())
	}
}
resultCodeGenerator.dependsOn "parseProtoh"
compileJava.dependsOn "resultCodeGenerator"

static boolean isCallType(String name) {
	return name.startsWith("SUPLA_CS_") ||
		name.startsWith("SUPLA_DCS_") ||
		name.startsWith("SUPLA_DS_") ||
		name.startsWith("SUPLA_SC_") ||
		name.startsWith("SUPLA_SD_") ||
		name.startsWith("SUPLA_SDC_")
}

static boolean isResultCode(String name) {
	if (name == "SUPLA_RESULTCODE_DENY_CHANNEL_IS_ASSOCIETED_WITH_ACTION_TRIGGER") {
		return false
	}
	name.startsWith("SUPLA_RESULTCODE_")
}

static void buildCallType(String callTypeName, String callTypePrefix, Path callTypesFolder, consts) {
	def className = callTypeName + "CallType"
	def fileName = className + ".java"
	def fields = consts.stream()
		.filter { it.name.startsWith(callTypePrefix) }
		.map {
			def javaDoc = ""
			if (it.javaDoc) {
				javaDoc = "/** ${it.javaDoc} */\n\t"
			}
			"$javaDoc${it.name}(${it.value})"
		}
		.collect(Collectors.joining(",\n\t"))
	def content = """\
		|package pl.grzeslowski.jsupla.protocol.api.calltypes;
		|
		|@lombok.Getter
		|@lombok.RequiredArgsConstructor
		|@javax.annotation.Generated(value="Prefix '$callTypePrefix'", date = "${ZonedDateTime.now()}")
		|public enum ${className} implements CallType {
		|	$fields;
		|	private final int value;
		|}""".stripMargin()

	callTypesFolder.resolve(fileName).write(content)
}

static String generateConst(constObj, List consts) {
	def value = consts
		.stream()
		.filter { it.name == constObj.value }
		.findAny()
	if (value.isPresent()) {
		def javaDoc = ""
		if (value.get().javaDoc) {
			javaDoc = "/** ${value.get().javaDoc} */\n\t"
		}
		def type = findType(value.get().value)
		return "${javaDoc}public static final $type ${constObj.name} = ${value.get().name};"
	}

	def javaDoc = ""
	if (constObj.javaDoc) {
		javaDoc = "/** ${constObj.javaDoc} */\n\t"
	}
	def type = findType(constObj.value)
	return "${javaDoc}public static final $type ${constObj.name} = ${mapValue(constObj.value)};"
}

static String mapValue(String value) {
	if (value == null) {
		return "true"
	}
	if (value == "\\") {
		return '"' + "\\\\" + '"'
	}
	if (value.matches(/\(1ULL << \d+\)/)) {
		return value.replaceAll(/(1ULL) << (\d+)/, '1L << $2')
	}
	if (value.matches(/\(1 << \d+\)/)) {
		return value.replaceAll(/(1) << (\d+)/, '1 << $2')
	}
	if (value.startsWith("0x")) {
		return value
	}
	try {
		Eval.me(value)
		return value
	} catch (Exception ignore) {
	}
	try {
		Integer.parseInt(value)
		return value
	} catch (NumberFormatException ignored) {
		return '"' + value + '"'
	}
}

static String findType(String value) {
	if (value == null) {
		return "boolean"
	}
	if (value.matches(/\(1ULL << \d+\)/)) {
		return "long"
	}
	if (value.contains("<<")) {
		return "int"
	}
	if (value.startsWith("0x")) {
		return "int"
	}
	try {
		def eval = Eval.me(value)
		def clazz = eval.class
		if (clazz == Integer.class) {
			return "int"
		}
		if (clazz == String.class) {
			return "String"
		}
		if (clazz == Long.class) {
			return "long"
		}
		return clazz.simpleName
	} catch (Exception ignore) {
	}
	try {
		Integer.parseInt(value)
		return "int"
	} catch (NumberFormatException ignored) {
		return "String"
	}
}

static boolean predefined(constObj, List overrides) {
	overrides.stream()
		.map { it.name }
		.anyMatch { it == constObj.name }
}